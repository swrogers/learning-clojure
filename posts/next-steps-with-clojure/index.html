<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<title>
      My Clojure Journey - Next Steps With Clojure
    </title>
<link rel="stylesheet" href="../../assets/css/bundle.css">
<script src="../../assets/js/bundle.js"></script>
</head>
<body>
    <div id="layout">
      <a href="#menu" id="menuLink" class="menu-link">
    <span></span>
</a>

<div id="menu">
    <div class="pure-menu">
        <a class="pure-menu-heading" href="../../">My Clojure Journey</a>

        <ul class="pure-menu-list">
<li class="pure-menu-item">
              <a class="pure-menu-link" href="../../archive.html">Archive</a>
            </li>
            <li class="pure-menu-item">
              <a class="pure-menu-link" href="../../categories/">Tags</a>
            </li>
            <li class="pure-menu-item">
              <a class="pure-menu-link" href="../../rss.xml">RSS feed</a>
            </li>


          
        </ul>
</div>
</div>

      <div id="main">

        
          


        <div class="yp-header-container">
            <div class="yp-header" style="border-bottom: 1px solid #eee;">

            <h1 class="yp-header__title">
              Next Steps With Clojure
            </h1>
            <h2 class="yp-header__subtitle">
              
            </h2>
            
          </div>
        </div>

        <div class="yp-content">
          








<div class="pure-g">
  <div class="pure-u-1">
    <article class="yp-post__body"><div>
<h2>Continuing the Clojure Journey</h2>
<h3>Forms</h3>
<p>LISP, and clojure, code is basically data. Valid code is referred to as a <code>form</code>.</p>
<p>The following are all valid forms:</p>
<pre class="code literal-block"><span class="mi">42</span>
<span class="s">"forty two"</span>
<span class="p">[</span><span class="s">"this"</span> <span class="s">"is"</span> <span class="s">"a"</span> <span class="s">"vector"</span> <span class="s">"that"</span> <span class="s">"contains"</span> <span class="s">"strings"</span><span class="p">]</span>
</pre>
<p>Since the above is generally not very useful, you build up programs with operators:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nf">operator</span> <span class="nv">operand1</span> <span class="nv">operand2</span> <span class="nv">operand3</span> <span class="nv">...</span> <span class="nv">operandn</span><span class="p">)</span>
</pre>
<p>Note the wrapping parenthesis. Note the distinct lack of commas.</p>
<h3>Control Flow</h3>
<h3>if</h3>
<p>Evaluates code based on truthiness or falsiness</p>
<pre class="code literal-block"><span class="p">(</span><span class="k">if </span><span class="nv">boolean-form</span>
    <span class="nv">then-form</span>
    <span class="nv">optional-else-form</span><span class="p">)</span>
</pre>
<p>Note that each branch can only have a single form to execute. This limitation can be worked around by using....</p>
<h4>do</h4>
<p>Used to <em>wrap up</em> multiple forms into a single form.</p>
<pre class="code literal-block"><span class="p">(</span><span class="k">do </span><span class="nv">form1</span>
    <span class="nv">form2</span>
    <span class="nv">...</span>
    <span class="nv">formn</span><span class="p">)</span>
</pre>
<pre class="code literal-block"><span class="p">(</span><span class="k">if </span><span class="nv">true</span>
    <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">"I'm a success!"</span><span class="p">)</span>
        <span class="s">"Another form here!!"</span>
        <span class="s">"Guess what?!"</span><span class="p">)</span>
    <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">"This would be a failure...."</span><span class="p">)</span>
        <span class="s">"Sad horn sound here."</span><span class="p">))</span>
</pre>
<p>Note also that the last item evaluated in the expression is also the return value. So in the example above, in the <code>true</code> case the return value would be <code>"Guess what?!"</code>.</p>
<h4>when</h4>
<p>Similar to <code>if</code>, without the <em>else</em> branch:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">when </span><span class="nv">true</span>
    <span class="p">(</span><span class="nb">println </span><span class="s">"truthy form"</span><span class="p">)</span>
    <span class="s">"return value form"</span><span class="p">)</span>
</pre>
<h3>Variable binding</h3>
<h4>def</h4>
<p><code>def</code> is used to bind a value to a name</p>
<pre class="code literal-block"><span class="p">(</span><span class="k">def </span><span class="nv">vector-of-strings</span>
    <span class="p">[</span><span class="s">"string one"</span> <span class="s">"string two"</span> <span class="s">"string three"</span><span class="p">])</span>
</pre>
<h3>Data structures</h3>
<h4>Numbers</h4>
<p>Numbers just <em>are</em>. Including <code>ratios</code>.</p>
<pre class="code literal-block"><span class="mi">12</span>
<span class="mf">89.4565</span>
<span class="mi">57</span><span class="nv">/125</span>
</pre>
<h4>strings</h4>
<p>Used to represent text, only used with double quotes, concatenation is by way of the <code>str</code> function.</p>
<pre class="code literal-block"><span class="s">"This is a string"</span>
<span class="s">"Want to get a double-quote in a string? Then you'll need to \" escape with the backslash."</span>
<span class="p">(</span><span class="nb">str </span><span class="s">"The str function "</span> <span class="s">"is used"</span> <span class="s">" to concat strings."</span>
    <span class="s">"Note the distinct lack of 'plusses' here."</span><span class="p">)</span>
</pre>
<h4>Maps</h4>
<p>Similar to a hash or dictionary, used to associate a value with a key.</p>
<pre class="code literal-block"><span class="p">{}</span>
<span class="p">{</span><span class="ss">:keyA</span> <span class="s">"valueA"</span>
<span class="ss">:keyB</span> <span class="s">"valueB"</span>
<span class="ss">:im-a-function</span> <span class="nv">+</span>
<span class="ss">:empty-map</span> <span class="p">{}}</span>
</pre>
<p>The <code>hash-map</code> function can be used to create a new map:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">hash-map </span><span class="ss">:key1</span> <span class="mi">1</span> <span class="ss">:key2</span> <span class="mi">2</span><span class="p">)</span>
</pre>
<p>Use the <code>get</code> function to look up values:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:key1</span> <span class="mi">1</span> <span class="ss">:key2</span> <span class="mi">2</span><span class="p">}</span> <span class="ss">:key2</span><span class="p">)</span>
</pre>
<p><code>get</code> returns <code>nil</code> if the key is not found, so you can give it a default value to return:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:key</span> <span class="nv">a</span> <span class="ss">:anotherkey</span> <span class="nv">b</span><span class="p">}</span> <span class="ss">:non-existant-key</span> <span class="s">"value not found, sorrry"</span><span class="p">)</span>
</pre>
<p>As maps can be nested, the <code>get-in</code> function can look inside children maps. The following would return the string "stringy here":</p>
<pre class="code literal-block"><span class="p">(</span><span class="nf">get-in</span> <span class="p">{</span><span class="ss">:not-nested</span> <span class="mi">1</span> <span class="ss">:is-nested</span> <span class="p">{</span><span class="ss">:child-map</span> <span class="s">"stringy here"</span><span class="p">}}</span> 
    <span class="p">[</span><span class="ss">:is-nested</span> <span class="ss">:child-map</span><span class="p">])</span>
</pre>
<p>A shortcut syntax to access a value in a map is the following method, which treats the map as a function and the key you're needing as a parameter:</p>
<pre class="code literal-block"><span class="p">({</span><span class="ss">:need-to-access-this</span> <span class="s">"really want this value"</span><span class="p">}</span> <span class="ss">:need-to-access-this</span><span class="p">)</span>
</pre>
<h5>Keywords</h5>
<p>Generally used as, well, <em>keys</em> in a map, they can also be used as functions that fetch their value in a structure - similarly as noted above:</p>
<pre class="code literal-block"><span class="ss">:this-is-a-key</span>
<span class="ss">:anotherKey</span>
<span class="ss">:42</span>
</pre>
<p>When used as functions:</p>
<pre class="code literal-block"><span class="p">(</span><span class="ss">:keyC</span> <span class="p">{</span><span class="ss">:keyA</span> <span class="mi">1</span> <span class="ss">:keyB</span> <span class="mi">2</span> <span class="ss">:key3</span> <span class="mi">5</span> <span class="ss">:keyC</span> <span class="mi">87</span><span class="p">})</span>
</pre>
<p>The previous example would be identical to the following:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:keyA</span> <span class="mi">1</span> <span class="ss">:keyB</span> <span class="mi">2</span> <span class="ss">:key3</span> <span class="mi">5</span> <span class="ss">:keyC</span> <span class="mi">87</span><span class="p">}</span> <span class="ss">:keyC</span><span class="p">)</span>
</pre>
<p>Default values can be provided as well:</p>
<pre class="code literal-block"><span class="p">(</span><span class="ss">:not-gonna-find-this</span> <span class="p">{</span><span class="nv">a</span><span class="err">:</span> <span class="mi">1</span> <span class="nv">b</span><span class="err">:</span> <span class="mi">2</span> <span class="nv">c</span><span class="err">:</span> <span class="mi">3</span><span class="p">}</span> <span class="s">"We did not find that key."</span><span class="p">)</span>
</pre>
<h4>Vectors</h4>
<p>A 0-indexed collection, similar to an array.</p>
<pre class="code literal-block"><span class="p">[</span><span class="mi">5</span> <span class="mi">8</span> <span class="mi">0</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span> <span class="s">"string"</span> <span class="p">{</span><span class="ss">:key</span> <span class="s">"value"</span><span class="p">}</span> <span class="nv">nil</span><span class="p">]</span>
</pre>
<p>Can use <code>get</code> to access items, this returns <code>1</code>:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">get </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">0</span><span class="p">)</span>
</pre>
<p>Use the <code>vector</code> function to make them manually, for fun and profit:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">vector </span><span class="s">"a"</span> <span class="s">"b"</span> <span class="s">"c"</span><span class="p">)</span>
</pre>
<p>Use <code>conj</code> (conjunction) to add elements to the <em>end</em> of a vector:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">1</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">67</span><span class="p">]</span> <span class="mi">9</span><span class="p">)</span>
</pre>
<h4>Lists</h4>
<p>Clojure wouldn't be a LISP without Lists...lists are denoted with a single quote <code>'</code>. </p>
<pre class="code literal-block"><span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre>
<p>Instead of <code>get</code>, use <code>nth</code> to retrieve items from a list:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">nth </span><span class="o">'</span><span class="p">(</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</pre>
<p>Lists can be created with the <code>list</code> function:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">list </span><span class="mi">8</span> <span class="s">"string"</span> <span class="p">{</span><span class="mi">5</span> <span class="mi">4</span><span class="p">})</span>
</pre>
<p>To swap things up for a change, the <code>conj</code> function adds to the <em>beginning</em> of lists:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">conj </span><span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
</pre>
<p>Lists are good for needing to add to the beginning of a sequence, otherwise use a vector.</p>
<h4>Sets</h4>
<p>Come in hash-sets and sorted-sets. Here's a hash-set:</p>
<pre class="code literal-block"><span class="o">#</span><span class="p">{</span><span class="s">"string"</span> <span class="mi">5</span> <span class="ss">:key</span> <span class="s">"whatever"</span><span class="p">}</span>
</pre>
<p>And another, made with <code>hash-set</code>:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">hash-set </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre>
<p>Keep in mind, that there are no duplicates in a hash set.</p>
<p>Hash sets can be created with the <code>set</code> function as well, from existing vectors:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">set </span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
</pre>
<p>Use <code>contains?</code> to check for existance within the set:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">contains? </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="mi">0</span> <span class="mi">1</span> <span class="s">"string"</span><span class="p">}</span> <span class="ss">:b</span><span class="p">)</span>
<span class="p">(</span><span class="nb">contains? </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="mi">0</span> <span class="mi">1</span> <span class="s">"string"</span><span class="p">}</span> <span class="ss">:not-gonna-find-me</span><span class="p">)</span>
</pre>
<p>Keywords work the same as in Maps:</p>
<pre class="code literal-block"><span class="p">(</span><span class="ss">:keyItem</span> <span class="o">#</span><span class="p">{</span><span class="ss">:keyItem</span> <span class="ss">:keyItemAnother</span><span class="p">})</span>
</pre>
<p>The above returns <code>:keyItem</code>. </p>
<p>The <code>get</code> function works as expected, too.</p>
</div>
    </article>
</div>
</div>
        </div>


          <div class="yp-footer">
    Contents © 2021         <a href="mailto:swrogers@gmail.com">Shane Rogers</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
    
  </div>

      </div>
    </div>

    
    
  </body>
</html>
