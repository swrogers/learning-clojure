<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<title>
      My Clojure Journey - Clojure and Functions
    </title>
<link rel="stylesheet" href="../../assets/css/bundle.css">
<script src="../../assets/js/bundle.js"></script>
</head>
<body>
    <div id="layout">
      <a href="#menu" id="menuLink" class="menu-link">
    <span></span>
</a>

<div id="menu">
    <div class="pure-menu">
        <a class="pure-menu-heading" href="../../">My Clojure Journey</a>

        <ul class="pure-menu-list">
<li class="pure-menu-item">
              <a class="pure-menu-link" href="../../archive.html">Archive</a>
            </li>
            <li class="pure-menu-item">
              <a class="pure-menu-link" href="../../categories/">Tags</a>
            </li>
            <li class="pure-menu-item">
              <a class="pure-menu-link" href="../../rss.xml">RSS feed</a>
            </li>


          
        </ul>
</div>
</div>

      <div id="main">

        
          


        <div class="yp-header-container">
            <div class="yp-header" style="border-bottom: 1px solid #eee;">

            <h1 class="yp-header__title">
              Clojure and Functions
            </h1>
            <h2 class="yp-header__subtitle">
              
            </h2>
            
          </div>
        </div>

        <div class="yp-content">
          








<div class="pure-g">
  <div class="pure-u-1">
    <article class="yp-post__body"><div>
<h3>Clojure and Functions</h3>
<p>With basics covered, time to cover functions.</p>
<p>Use <code>defn</code> to define one's own functions. Function definitions have five parts:</p>
<ul>
<li>
<p>defn</p>
</li>
<li>
<p>Function Name</p>
</li>
<li>
<p>Optional - Docstring</p>
</li>
<li>
<p>bracket of parameters</p>
</li>
<li>
<p>function body</p>
</li>
</ul>
<p>Example:</p>
<pre class="code literal-block"><span class="p">(</span><span class="kd">defn </span><span class="nv">function-name</span>
    <span class="s">"This is an interesting function that does something nifty."</span>
    <span class="p">[</span><span class="nv">parameter</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">"Let's build a string! Your parameter was "</span> <span class="nv">parameter</span><span class="p">))</span>

<span class="p">(</span><span class="nf">function-name</span> <span class="s">"PARAMETER HERE!!"</span><span class="p">)</span>
</pre>
<h4>Arity and overloading</h4>
<p>Functions have an <em>arity</em>, that is, how many parameters they take. Functions can be overloaded to run different forms depending on arity. Note that each function form is wrapped in its own paren set:</p>
<pre class="code literal-block"><span class="p">(</span><span class="kd">defn </span><span class="nv">overloaded-function</span>
    <span class="c1">;; 3 arity</span>
    <span class="p">([</span><span class="nv">one</span> <span class="nv">two</span> <span class="nv">three</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">"one: "</span> <span class="nv">one</span> <span class="s">"two: "</span> <span class="nv">two</span> <span class="s">"three: "</span> <span class="nv">three</span><span class="p">))</span>
    <span class="c1">;; 2 arity</span>
    <span class="p">([</span><span class="nv">one</span> <span class="nv">two</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">"one: "</span> <span class="nv">one</span> <span class="s">"two: "</span> <span class="nv">two</span><span class="p">))</span>
    <span class="c1">;; 1 arity</span>
    <span class="p">([</span><span class="nv">one</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">"one: "</span> <span class="nv">one</span><span class="p">))</span>
    <span class="c1">;; 0 arity</span>
    <span class="p">([]</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">"no args here!"</span><span class="p">)))</span>
</pre>
<p>You can use the above as a method to provide default arguments, by calling the function from itself:</p>
<pre class="code literal-block"><span class="p">(</span><span class="kd">defn </span><span class="nv">i-have-default-second-arg</span>
    <span class="s">"The second argument will have a default here..."</span>
    <span class="p">([</span><span class="nv">arg1</span> <span class="nv">arg2</span><span class="p">]</span>
        <span class="p">(</span><span class="nb">str </span><span class="s">"arg1: "</span> <span class="nv">arg1</span> <span class="s">"arg2: "</span> <span class="nv">arg2</span><span class="p">))</span>
    <span class="p">([</span><span class="nv">arg1</span><span class="p">]</span>
        <span class="p">(</span><span class="nf">i-have-default-second-arg</span> <span class="nv">arg1</span> <span class="s">"default"</span><span class="p">)))</span>
</pre>
<h4>The <code>Rest</code> parameter</h4>
<p>Another way to define multi-arity functions is with the <em>rest</em> parameter: <code>&amp;</code>.  When this method is used, it says to place all the rest of the included parameters into the named list.</p>
<pre class="code literal-block"><span class="p">(</span><span class="kd">defn </span><span class="nv">named-shopping-list</span>
    <span class="s">"The first parameter will be the name of the list: list-name.</span>
<span class="s">     The remaining parameters will be added to the list: shopping-list"</span>
    <span class="p">[</span><span class="nv">list-name</span> <span class="o">&amp;</span> <span class="nv">shopping-list</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">str </span><span class="s">"List name: "</span> <span class="nv">list-name</span>
        <span class="s">"List items: "</span> <span class="nv">shopping-list</span><span class="p">))</span>
</pre>
<h4>Destructuring</h4>
<p>Another way to define parameters, binding names to items within the collection.</p>
<p>This is done by passing the parameter list inside a vector. Lists, vectors and maps can be destructured.</p>
<pre class="code literal-block"><span class="p">(</span><span class="kd">defn </span><span class="nv">simple-destruct</span>
    <span class="s">"just grab the first thing from the passed in list"</span>
    <span class="p">[[</span><span class="nv">first-thing</span><span class="p">]]</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"The first thing was "</span> <span class="nv">first-thing</span><span class="p">)))</span>


<span class="p">(</span><span class="k">def </span><span class="nv">map-destruct</span>
    <span class="p">[{</span><span class="nv">keyOne</span> <span class="ss">:keyOne</span> <span class="nv">keyTwo</span> <span class="ss">:keyTwo</span><span class="p">}]</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"One: "</span> <span class="nv">keyOne</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"Two: "</span> <span class="nv">keyTwo</span><span class="p">)))</span>
</pre>
<p>A shorter, simpler way to break out keywords of a map for parameters would be...</p>
<pre class="code literal-block"><span class="p">(</span><span class="k">def </span><span class="nv">map-destruct</span>
    <span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">keyOne</span> <span class="nv">keyTwo</span><span class="p">]}]</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"One: "</span> <span class="nv">keyOne</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"Two: "</span> <span class="nv">keyTwo</span><span class="p">)))</span>
</pre>
<p>The <code>:as</code> keyword saves access to the original map argument:</p>
<pre class="code literal-block"><span class="p">(</span><span class="k">def </span><span class="nv">map-destruct</span>
    <span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">keyOne</span> <span class="nv">keyTwo</span><span class="p">]</span> <span class="ss">:as</span> <span class="nv">parm-map</span><span class="p">}]</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"One: "</span> <span class="nv">keyOne</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"Two: "</span> <span class="nv">keyTwo</span><span class="p">)))</span>
</pre>
<h4>Anonymous Functions</h4>
<p>Functions that don't have names are <em>anonymous functions</em>.</p>
<pre class="code literal-block"><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">parameters</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="s">"I don't do anything with these: "</span> <span class="nv">parameters</span><span class="p">)))</span>
</pre>
<p>You could do this, if you wanted:</p>
<pre class="code literal-block"><span class="p">(</span><span class="k">def </span><span class="nv">named-function-from-anonymous</span> 
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">parm</span><span class="p">]</span> 
<span class="p">(</span><span class="nb">str </span><span class="s">"This is the parm "</span> <span class="nv">parm</span><span class="p">)))</span>
</pre>
<p>Here we have a more compact way to define anonymous functions:</p>
<pre class="code literal-block"><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">;; the above function, applied...</span>
<span class="p">(</span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">; =&gt; 6</span>
</pre>
<p>...another example:</p>
<pre class="code literal-block"><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">str </span><span class="s">"Hi, "</span> <span class="nv">%</span><span class="p">)</span>
    <span class="p">[</span><span class="s">"name one"</span> <span class="s">"name two"</span> <span class="s">"name three"</span><span class="p">])</span>
</pre>
<p>The <code>#</code> turns the function into an anonymous function, the <code>%</code> serves as a placeholder for any argument. If you need more than one argument, then just increment them: <code>%1</code>, <code>%2</code>, <code>%3</code>, and on. If you want to use a <em>rest</em> item, then use <code>%&amp;</code>, as expected.</p>
</div>
    </article>
</div>
</div>
        </div>


          <div class="yp-footer">
    Contents © 2021         <a href="mailto:swrogers@gmail.com">Shane Rogers</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
    
  </div>

      </div>
    </div>

    
    
  </body>
</html>
