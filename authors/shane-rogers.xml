<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>My Clojure Journey (Posts by Shane Rogers)</title><link>https://swrogers.github.io/learning-clojure/</link><description></description><atom:link href="https://swrogers.github.io/learning-clojure/authors/shane-rogers.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2021 &lt;a href="mailto:swrogers@gmail.com"&gt;Shane Rogers&lt;/a&gt; </copyright><lastBuildDate>Fri, 19 Feb 2021 22:42:00 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Clojure and Functions</title><link>https://swrogers.github.io/learning-clojure/posts/clojure-and-functions/</link><dc:creator>Shane Rogers</dc:creator><description>&lt;div&gt;&lt;h3&gt;Clojure and Functions&lt;/h3&gt;
&lt;p&gt;With basics covered, time to cover functions.&lt;/p&gt;
&lt;p&gt;Use &lt;code&gt;defn&lt;/code&gt; to define one's own functions. Function definitions have five parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;defn&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function Name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Optional - Docstring&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bracket of parameters&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function body&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;function-name&lt;/span&gt;
    &lt;span class="s"&gt;"This is an interesting function that does something nifty."&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;parameter&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"Let's build a string! Your parameter was "&lt;/span&gt; &lt;span class="nv"&gt;parameter&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;function-name&lt;/span&gt; &lt;span class="s"&gt;"PARAMETER HERE!!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;Arity and overloading&lt;/h4&gt;
&lt;p&gt;Functions have an &lt;em&gt;arity&lt;/em&gt;, that is, how many parameters they take. Functions can be overloaded to run different forms depending on arity. Note that each function form is wrapped in its own paren set:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;overloaded-function&lt;/span&gt;
    &lt;span class="c1"&gt;;; 3 arity&lt;/span&gt;
    &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;one&lt;/span&gt; &lt;span class="nv"&gt;two&lt;/span&gt; &lt;span class="nv"&gt;three&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"one: "&lt;/span&gt; &lt;span class="nv"&gt;one&lt;/span&gt; &lt;span class="s"&gt;"two: "&lt;/span&gt; &lt;span class="nv"&gt;two&lt;/span&gt; &lt;span class="s"&gt;"three: "&lt;/span&gt; &lt;span class="nv"&gt;three&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;; 2 arity&lt;/span&gt;
    &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;one&lt;/span&gt; &lt;span class="nv"&gt;two&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"one: "&lt;/span&gt; &lt;span class="nv"&gt;one&lt;/span&gt; &lt;span class="s"&gt;"two: "&lt;/span&gt; &lt;span class="nv"&gt;two&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;; 1 arity&lt;/span&gt;
    &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;one&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"one: "&lt;/span&gt; &lt;span class="nv"&gt;one&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;; 0 arity&lt;/span&gt;
    &lt;span class="p"&gt;([]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"no args here!"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;You can use the above as a method to provide default arguments, by calling the function from itself:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;i-have-default-second-arg&lt;/span&gt;
    &lt;span class="s"&gt;"The second argument will have a default here..."&lt;/span&gt;
    &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;arg1&lt;/span&gt; &lt;span class="nv"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"arg1: "&lt;/span&gt; &lt;span class="nv"&gt;arg1&lt;/span&gt; &lt;span class="s"&gt;"arg2: "&lt;/span&gt; &lt;span class="nv"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nv"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;i-have-default-second-arg&lt;/span&gt; &lt;span class="nv"&gt;arg1&lt;/span&gt; &lt;span class="s"&gt;"default"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;The &lt;code&gt;Rest&lt;/code&gt; parameter&lt;/h4&gt;
&lt;p&gt;Another way to define multi-arity functions is with the &lt;em&gt;rest&lt;/em&gt; parameter: &lt;code&gt;&amp;amp;&lt;/code&gt;.  When this method is used, it says to place all the rest of the included parameters into the named list.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;defn &lt;/span&gt;&lt;span class="nv"&gt;named-shopping-list&lt;/span&gt;
    &lt;span class="s"&gt;"The first parameter will be the name of the list: list-name.&lt;/span&gt;
&lt;span class="s"&gt;     The remaining parameters will be added to the list: shopping-list"&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;list-name&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nv"&gt;shopping-list&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"List name: "&lt;/span&gt; &lt;span class="nv"&gt;list-name&lt;/span&gt;
        &lt;span class="s"&gt;"List items: "&lt;/span&gt; &lt;span class="nv"&gt;shopping-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;Destructuring&lt;/h4&gt;
&lt;p&gt;Another way to define parameters, binding names to items within the collection.&lt;/p&gt;
&lt;p&gt;This is done by passing the parameter list inside a vector.&lt;/p&gt;&lt;/div&gt;</description><guid>https://swrogers.github.io/learning-clojure/posts/clojure-and-functions/</guid><pubDate>Fri, 19 Feb 2021 22:03:12 GMT</pubDate></item><item><title>Next Steps With Clojure</title><link>https://swrogers.github.io/learning-clojure/posts/next-steps-with-clojure/</link><dc:creator>Shane Rogers</dc:creator><description>&lt;div&gt;&lt;h2&gt;Continuing the Clojure Journey&lt;/h2&gt;
&lt;h3&gt;Forms&lt;/h3&gt;
&lt;p&gt;LISP, and clojure, code is basically data. Valid code is referred to as a &lt;code&gt;form&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following are all valid forms:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="mi"&gt;42&lt;/span&gt;
&lt;span class="s"&gt;"forty two"&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"this"&lt;/span&gt; &lt;span class="s"&gt;"is"&lt;/span&gt; &lt;span class="s"&gt;"a"&lt;/span&gt; &lt;span class="s"&gt;"vector"&lt;/span&gt; &lt;span class="s"&gt;"that"&lt;/span&gt; &lt;span class="s"&gt;"contains"&lt;/span&gt; &lt;span class="s"&gt;"strings"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Since the above is generally not very useful, you build up programs with operators:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;operator&lt;/span&gt; &lt;span class="nv"&gt;operand1&lt;/span&gt; &lt;span class="nv"&gt;operand2&lt;/span&gt; &lt;span class="nv"&gt;operand3&lt;/span&gt; &lt;span class="nv"&gt;...&lt;/span&gt; &lt;span class="nv"&gt;operandn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Note the wrapping parenthesis. Note the distinct lack of commas.&lt;/p&gt;
&lt;h3&gt;Control Flow&lt;/h3&gt;
&lt;h3&gt;if&lt;/h3&gt;
&lt;p&gt;Evaluates code based on truthiness or falsiness&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;boolean-form&lt;/span&gt;
    &lt;span class="nv"&gt;then-form&lt;/span&gt;
    &lt;span class="nv"&gt;optional-else-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Note that each branch can only have a single form to execute. This limitation can be worked around by using....&lt;/p&gt;
&lt;h4&gt;do&lt;/h4&gt;
&lt;p&gt;Used to &lt;em&gt;wrap up&lt;/em&gt; multiple forms into a single form.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="nv"&gt;form1&lt;/span&gt;
    &lt;span class="nv"&gt;form2&lt;/span&gt;
    &lt;span class="nv"&gt;...&lt;/span&gt;
    &lt;span class="nv"&gt;formn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"I'm a success!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="s"&gt;"Another form here!!"&lt;/span&gt;
        &lt;span class="s"&gt;"Guess what?!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"This would be a failure...."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="s"&gt;"Sad horn sound here."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Note also that the last item evaluated in the expression is also the return value. So in the example above, in the &lt;code&gt;true&lt;/code&gt; case the return value would be &lt;code&gt;"Guess what?!"&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;when&lt;/h4&gt;
&lt;p&gt;Similar to &lt;code&gt;if&lt;/code&gt;, without the &lt;em&gt;else&lt;/em&gt; branch:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"truthy form"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;"return value form"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;Variable binding&lt;/h3&gt;
&lt;h4&gt;def&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt; is used to bind a value to a name&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;vector-of-strings&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"string one"&lt;/span&gt; &lt;span class="s"&gt;"string two"&lt;/span&gt; &lt;span class="s"&gt;"string three"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;
&lt;h3&gt;Data structures&lt;/h3&gt;
&lt;h4&gt;Numbers&lt;/h4&gt;
&lt;p&gt;Numbers just &lt;em&gt;are&lt;/em&gt;. Including &lt;code&gt;ratios&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="mi"&gt;12&lt;/span&gt;
&lt;span class="mf"&gt;89.4565&lt;/span&gt;
&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="nv"&gt;/125&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;strings&lt;/h4&gt;
&lt;p&gt;Used to represent text, only used with double quotes, concatenation is by way of the &lt;code&gt;str&lt;/code&gt; function.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="s"&gt;"This is a string"&lt;/span&gt;
&lt;span class="s"&gt;"Want to get a double-quote in a string? Then you'll need to \" escape with the backslash."&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str &lt;/span&gt;&lt;span class="s"&gt;"The str function "&lt;/span&gt; &lt;span class="s"&gt;"is used"&lt;/span&gt; &lt;span class="s"&gt;" to concat strings."&lt;/span&gt;
    &lt;span class="s"&gt;"Note the distinct lack of 'plusses' here."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;Maps&lt;/h4&gt;
&lt;p&gt;Similar to a hash or dictionary, used to associate a value with a key.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:keyA&lt;/span&gt; &lt;span class="s"&gt;"valueA"&lt;/span&gt;
&lt;span class="ss"&gt;:keyB&lt;/span&gt; &lt;span class="s"&gt;"valueB"&lt;/span&gt;
&lt;span class="ss"&gt;:im-a-function&lt;/span&gt; &lt;span class="nv"&gt;+&lt;/span&gt;
&lt;span class="ss"&gt;:empty-map&lt;/span&gt; &lt;span class="p"&gt;{}}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;hash-map&lt;/code&gt; function can be used to create a new map:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-map &lt;/span&gt;&lt;span class="ss"&gt;:key1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;:key2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Use the &lt;code&gt;get&lt;/code&gt; function to look up values:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;get &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:key1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;:key2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="ss"&gt;:key2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if the key is not found, so you can give it a default value to return:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;get &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:key&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="ss"&gt;:anotherkey&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="ss"&gt;:non-existant-key&lt;/span&gt; &lt;span class="s"&gt;"value not found, sorrry"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;As maps can be nested, the &lt;code&gt;get-in&lt;/code&gt; function can look inside children maps. The following would return the string "stringy here":&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-in&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:not-nested&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;:is-nested&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:child-map&lt;/span&gt; &lt;span class="s"&gt;"stringy here"&lt;/span&gt;&lt;span class="p"&gt;}}&lt;/span&gt; 
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="ss"&gt;:is-nested&lt;/span&gt; &lt;span class="ss"&gt;:child-map&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;A shortcut syntax to access a value in a map is the following method, which treats the map as a function and the key you're needing as a parameter:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="ss"&gt;:need-to-access-this&lt;/span&gt; &lt;span class="s"&gt;"really want this value"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="ss"&gt;:need-to-access-this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h5&gt;Keywords&lt;/h5&gt;
&lt;p&gt;Generally used as, well, &lt;em&gt;keys&lt;/em&gt; in a map, they can also be used as functions that fetch their value in a structure - similarly as noted above:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="ss"&gt;:this-is-a-key&lt;/span&gt;
&lt;span class="ss"&gt;:anotherKey&lt;/span&gt;
&lt;span class="ss"&gt;:42&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;When used as functions:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:keyC&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:keyA&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;:keyB&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;:key3&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ss"&gt;:keyC&lt;/span&gt; &lt;span class="mi"&gt;87&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The previous example would be identical to the following:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;get &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:keyA&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ss"&gt;:keyB&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;:key3&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ss"&gt;:keyC&lt;/span&gt; &lt;span class="mi"&gt;87&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="ss"&gt;:keyC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Default values can be provided as well:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:not-gonna-find-this&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="s"&gt;"We did not find that key."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;Vectors&lt;/h4&gt;
&lt;p&gt;A 0-indexed collection, similar to an array.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:key&lt;/span&gt; &lt;span class="s"&gt;"value"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Can use &lt;code&gt;get&lt;/code&gt; to access items, this returns &lt;code&gt;1&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;get &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Use the &lt;code&gt;vector&lt;/code&gt; function to make them manually, for fun and profit:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;vector &lt;/span&gt;&lt;span class="s"&gt;"a"&lt;/span&gt; &lt;span class="s"&gt;"b"&lt;/span&gt; &lt;span class="s"&gt;"c"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Use &lt;code&gt;conj&lt;/code&gt; (conjunction) to add elements to the &lt;em&gt;end&lt;/em&gt; of a vector:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;Lists&lt;/h4&gt;
&lt;p&gt;Clojure wouldn't be a LISP without Lists...lists are denoted with a single quote &lt;code&gt;'&lt;/code&gt;. &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Instead of &lt;code&gt;get&lt;/code&gt;, use &lt;code&gt;nth&lt;/code&gt; to retrieve items from a list:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nth &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt; &lt;span class="ss"&gt;:c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Lists can be created with the &lt;code&gt;list&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;To swap things up for a change, the &lt;code&gt;conj&lt;/code&gt; function adds to the &lt;em&gt;beginning&lt;/em&gt; of lists:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;conj &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Lists are good for needing to add to the beginning of a sequence, otherwise use a vector.&lt;/p&gt;
&lt;h4&gt;Sets&lt;/h4&gt;
&lt;p&gt;Come in hash-sets and sorted-sets. Here's a hash-set:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"string"&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="ss"&gt;:key&lt;/span&gt; &lt;span class="s"&gt;"whatever"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;And another, made with &lt;code&gt;hash-set&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-set &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Keep in mind, that there are no duplicates in a hash set.&lt;/p&gt;
&lt;p&gt;Hash sets can be created with the &lt;code&gt;set&lt;/code&gt; function as well, from existing vectors:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;set &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Use &lt;code&gt;contains?&lt;/code&gt; to check for existance within the set:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;contains? &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;contains? &lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="s"&gt;"string"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="ss"&gt;:not-gonna-find-me&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Keywords work the same as in Maps:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:keyItem&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:keyItem&lt;/span&gt; &lt;span class="ss"&gt;:keyItemAnother&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The above returns &lt;code&gt;:keyItem&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; function works as expected, too.&lt;/p&gt;&lt;/div&gt;</description><guid>https://swrogers.github.io/learning-clojure/posts/next-steps-with-clojure/</guid><pubDate>Fri, 19 Feb 2021 21:14:51 GMT</pubDate></item><item><title>My Clojure Journey</title><link>https://swrogers.github.io/learning-clojure/posts/my-clojure-journey/</link><dc:creator>Shane Rogers</dc:creator><description>&lt;div&gt;&lt;h2&gt;My Clojure Journey&lt;/h2&gt;
&lt;p&gt;Welcome to my little journey on attempting to learn Clojure!&lt;/p&gt;
&lt;p&gt;This is going to be the place where, once the day has come to wind down, I'll recap everything that I've learned during the day. The hope is, that upon doing so it will help to cement things into my long term memory and actually be able to use the language.&lt;/p&gt;
&lt;h2&gt;The First Steps&lt;/h2&gt;
&lt;p&gt;Since I've already been at this for a couple of days, I figure that now is as good a time as any to recap things for myself. The idea here is that as I travel through the braveclojure.com site, at the end of each day I'll write up what it was that I learned as an attempt to try to keep things fresh and retained.&lt;/p&gt;
&lt;p&gt;We'll see how this goes.&lt;/p&gt;
&lt;h3&gt;Creating new clojure projects&lt;/h3&gt;
&lt;p&gt;New clojure projects can be created with the &lt;a href="http://leiningen.org/"&gt;Leiningen&lt;/a&gt; command line application. Installation is pretty straightforward for us Linux users. It's kind of a given, I would assume, that since clojure runs on the JVM that you would already have a Java Runtime installed.&lt;/p&gt;
&lt;p&gt;New clojure projects are created by:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;lein new app &amp;lt;name-of-project&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Lein can also be used to run your project, first navigate into the newly created directory and...&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &amp;lt;name-of-project&amp;gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; lein run
&lt;/pre&gt;
&lt;p&gt;Lein can create distributables...&lt;/p&gt;
&lt;pre class="code literal-block"&gt;lein uberjar
&lt;/pre&gt;
&lt;p&gt;The above creates the &lt;em&gt;target/uberjar/&lt;name-of-project-with-release-data&gt;-standalone.jar&lt;/name-of-project-with-release-data&gt;&lt;/em&gt; file.&lt;/p&gt;
&lt;p&gt;Lein can be used to access a REPL:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;lein repl
&lt;/pre&gt;
&lt;p&gt;Of course, you'll most likely want to use an actual editor, which brings us to....Emacs.&lt;/p&gt;
&lt;h2&gt;Emacs - The Ultimate Clojure Editor&lt;/h2&gt;
&lt;p&gt;If I'm being honestly frank, and it's more like honestly Shane...but whatever....the reason I wanted to pick up a LISP is because I've been wanting to get more in depth into Emacs. Since Emacs is basically a LISP machine, it helps to have some knowledge of LISP in order to use Emacs to its fullest. That, and who knows, maybe learning Clojure can help with future employment prospects, self taught or not.&lt;/p&gt;
&lt;p&gt;One thing that I have been doing over the past few months, is building up &lt;a href="https://gitlab.swrgroups.net/swrogers/dot-emacs-config"&gt;my Emacs config&lt;/a&gt; from scratch using Org mode. Which is, in and of itself, quite a time consuming beast. For Clojure, I've been using a handful of handy packages.&lt;/p&gt;
&lt;h3&gt;Emacs Keyboard References&lt;/h3&gt;
&lt;p&gt;Here is a handy table of Emacs keys that one might find useful from this page&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Keyboard shortcut&lt;/th&gt;
&lt;th&gt;Function name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Create buffer&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; &lt;kbd&gt;b&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;switch-to-buffer&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kill buffer&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; &lt;kbd&gt;k&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Visit file&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; &lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;f&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Save file&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; &lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;s&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;save-file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kill line&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;k&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Undo&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C&lt;/kbd&gt;-&lt;kbd&gt;/&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;CIDER Keyboard Reference&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Keyboard shortcut&lt;/th&gt;
&lt;th&gt;Function name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Eval last expression&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-x C-e&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;cider-eval-last-expression&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Set namespace&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-c M-n M-n&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compile buffer&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-c C-k&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cycle REPL history&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-[UP]&lt;/kbd&gt; or &lt;kbd&gt;C-[DOWN]&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Display Documentation for symbol at point&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-c C-d C-d&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Navigate to source for symbol at point&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;M-.&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Navigate back to original buffer and position&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;M-,&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Search for arbitrary text across function names and documentation&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-c C-d C-a&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Paredit Keyboard Reference&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Keyboard shortcut&lt;/th&gt;
&lt;th&gt;Function name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Wrap&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;M-(&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Slurp&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-[RIGHT]&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Barf&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-[LEFT]&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Move to closing parens&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-M-f&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Move to opening parens&lt;/td&gt;
&lt;td&gt;&lt;kbd&gt;C-M-b&lt;/kbd&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;Now to actually start learning the language&lt;/h3&gt;
&lt;p&gt;Hopefully that makes some sense, now it's on to starting to learn things...&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><guid>https://swrogers.github.io/learning-clojure/posts/my-clojure-journey/</guid><pubDate>Fri, 19 Feb 2021 20:22:33 GMT</pubDate></item></channel></rss>